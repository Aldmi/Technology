Если async-метод действительно работает асинхронно, то, как мы ви-
дели, львиная доля накладных расходов приходится на обращение
к методу Post вызывающего контекста SynchronizationContext, в
результате которого происходит переключение потоков. В разделе
«Когда не следует использовать SynchronizationContext» мы гово-
рили, что метод Con fi gureAwait позволяет подавить вызов Post и
тем самым не платить за переключение потоков, когда без него мож-
но обойтись. Если ваш код вызывается из потока пользовательского
интерфейса в WPF, то такое решение позволит избежать повторных
вызовов Post.

byte[] bytes = await client.DownloadDataTaskAsync(url).Con fi gureAwait(false);
